<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Columns, Readers, and Datatypes</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">tech.ml.dataset</span> <span class="project-version">5.0.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="columns-readers-and-datatypes.html"><div class="inner"><span>Columns, Readers, and Datatypes</span></div></a></li><li class="depth-1 "><a href="csv-space-operations.html"><div class="inner"><span>CSV Space Operations</span></div></a></li><li class="depth-1 "><a href="nippy-serialization-rocks.html"><div class="inner"><span>Nippy Rocks!</span></div></a></li><li class="depth-1 "><a href="quick-reference.html"><div class="inner"><span>Quick Reference - Core API</span></div></a></li><li class="depth-1 "><a href="walkthrough.html"><div class="inner"><span>tech.ml.dataset Walkthrough</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="tech.v3.dataset.html"><div class="inner"><span>tech.v3.dataset</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#columns-readers-and-datatypes" name="columns-readers-and-datatypes"></a>Columns, Readers, and Datatypes</h1>
<p>In <code>tech.ml.dataset</code>, columns are composed of three things: <a href="https://github.com/techascent/tech.ml.dataset/blob/0ec64ac6bf5c5536491202b1abd3da7abbec1109/src/tech/ml/dataset/impl/column.clj#L141">data, metadata, and the missing set</a>. The column’s datatype is the datatype of the <code>data</code> member. The data member can be anything convertible to a tech.v2.datatype reader of the appropriate type.</p>
<p>Readers are a simple abstraction of typed random access read-only memory. You can create a reader by reifying the appropriately typed interface from <code>tech.v2.datatype</code> but the datatype library has <a href="https://github.com/techascent/tech.datatype/blob/5b4745f728a2773ae542fac9613ffd1c482b9750/src/tech/v2/datatype.clj#L458">quick paths</a> to creating these:</p>
<pre><code class="clojure">user&gt; (require '[tech.v2.datatype :as dtype])
nil
user&gt; (dtype/make-reader :float32 5 idx)
[0.0 1.0 2.0 3.0 4.0]
user&gt; (dtype/make-reader :float32 5 (* 2 idx))
[0.0 2.0 4.0 6.0 8.0]
</code></pre>
<p>A reader has a three methods - <code>getDatatype</code> (optional), <code>lsize</code>, and <code>read</code>. <code>read</code> is typed to the datatype so for instance in the example above, read returns a primitive float object. <code>lsize</code> returns a long. Unlike a the similar method <code>get</code> in java lists, the <code>read</code> method takes a long. This allows us to use read methods on storage mechanism capable of addressing more than 2 (signed int) or 4 (unsigned int) billion addresses.</p>
<p>The dataset system in general is smart enough to create columns out of readers in most situations. So for instance if you have a dataset and you want a column of a particular type, you can add-or-update-column and pass in a reader that implements what you want:</p>
<pre><code class="clojure">user&gt; (def stocks (ds/-&gt;dataset "test/data/stocks.csv"))
#'user/stocks
user&gt; (ds/head stocks)
test/data/stocks.csv [5 3]:

| symbol |       date | price |
|--------+------------+-------|
|   MSFT | 2000-01-01 | 39.81 |
|   MSFT | 2000-02-01 | 36.35 |
|   MSFT | 2000-03-01 | 43.22 |
|   MSFT | 2000-04-01 | 28.37 |
|   MSFT | 2000-05-01 | 25.45 |
user&gt; (ds/head (ds/add-or-update-column stocks "id"
                                        (dtype/make-reader :int64
                                                           (ds/row-count stocks)
                                                           idx)))
test/data/stocks.csv [5 4]:

| symbol |       date | price | id |
|--------+------------+-------+----|
|   MSFT | 2000-01-01 | 39.81 |  0 |
|   MSFT | 2000-02-01 | 36.35 |  1 |
|   MSFT | 2000-03-01 | 43.22 |  2 |
|   MSFT | 2000-04-01 | 28.37 |  3 |
|   MSFT | 2000-05-01 | 25.45 |  4 |
</code></pre>
<p>There are many different datatypes currently used in the datatype system - the primitive numeric types: * <code>:boolean</code> - convert to and from 0 (false) or 1 (true) when used as a number. * <code>:int8</code>,<code>:uint8</code> - signed/unsigned bytes. * <code>:int16</code>,<code>:uint16</code> - signed/unsigned shorts. * <code>:int32</code>,<code>:uint32</code> - signed/unsigned ints. * <code>:int64</code> - signed longs (haven’t figured out unsigned longs really yet). * <code>:float32</code>, <code>float64</code> - floats, doubles respectively.</p>
<p>There are more types that can be represented by primitives (they ‘alias’ the primitive type) but we will leave that for another article.</p>
<p>Outside of the primitive types (and types aliased to primitive types), we have an infinite object types. Any datatype the system doesn’t understand it will treat as type :object during generic options.</p>
<p>One very important aspect to note is that columns marked as <code>:object</code> datatypes will use the Clojure numerics stack during mathematical operations. This is important because Clojure number tower, similar to the APL number tower, actively promotes values to the next appropriate size and is thus less error prone to use if you aren’t absolutely certain of your value range how it interacts with your arithmetic pathways.</p>
<p>You can create a reader of any type you like and you can use any datastructure you like as a datatype. From the docstring on make-reader:</p>
<pre><code class="clojure"><br />-------------------------
tech.v2.datatype/make-reader
([datatype n-elems read-op])
Macro
  Make a reader.  Datatype must be a compile time visible object.
  read-op has 'idx' in scope which is the index to read from.  Returns a
  reader of the appropriate type for the passed in datatype.  Results are unchecked
  casted to the appropriate datatype.  It is up to *you* to ensure this is the result
  you want or throw an exception.

user&gt; (dtype/make-reader :float32 5 idx)
[0.0 1.0 2.0 3.0 4.0]
user&gt; (dtype/make-reader :boolean 5 idx)
[true true true true true]
user&gt; (dtype/make-reader :boolean 5 (== idx 0))
[true false false false false]
user&gt; (dtype/make-reader :float32 5 (* idx 2))
 [0.0 2.0 4.0 6.0 8.0]
user&gt; (dtype/make-reader :any-datatype-you-wish 5 (* idx 2))
[0 2 4 6 8]
user&gt; (dtype/get-datatype *1)
:any-datatype-you-wish
user&gt; (dtype/make-reader [:a :b] 5 (* idx 2))
[0 2 4 6 8]
user&gt; (dtype/get-datatype *1)
[:a :b]
</code></pre>
<p>This means you can make a column and mark it as any datatype that you like if you are ok with object semantics.</p>
<p>Often times it is useful to perform an operation on one or more columns and produce a new column. Almost anything you think of that will result in a countable thing will work fine (mapv, etc). If your operation results in a primitive element per index, it will often be very efficient to: 1. Use a let statement to type all the inputs to your operation. 2. Create a reader of the appropriate type that does the operation.</p>
<pre><code class="clojure">user&gt; (ds/head
       (ds/add-or-update-column
        stocks
        "price-lag"
        ;;This enables fast, typed random access to the data in the column
        (let [price-data (dtype/-&gt;typed-reader
                          (stocks "price") :float32)]
          (dtype/make-reader :float32 (.lsize price-data)
                             (.read price-data (max 0 (dec idx)))))))

test/data/stocks.csv [5 4]:

| symbol |       date | price | price-lag |
|--------+------------+-------+-----------|
|   MSFT | 2000-01-01 | 39.81 |     39.81 |
|   MSFT | 2000-02-01 | 36.35 |     39.81 |
|   MSFT | 2000-03-01 | 43.22 |     36.35 |
|   MSFT | 2000-04-01 | 28.37 |     43.22 |
|   MSFT | 2000-05-01 | 25.45 |     28.37 |
</code></pre>
<p>These columns will still work fine with the arithmetic subsystems:</p>
<pre><code class="clojure">user&gt; (require '[tech.v2.datatype.functional :as dfn])
user&gt; (def stocks-lag
       (ds/add-or-update-column
        stocks
        "price-lag"
        ;;This enables fast, typed random access to the data in the column
        (let [price-data (dtype/-&gt;typed-reader
                          (stocks "price") :float32)]
          (dtype/make-reader :float32 (.lsize price-data)
                             (.read price-data (max 0 (dec idx)))))))

#'user/stocks-lag
user&gt; (ds/head
       (ds/add-or-update-column
        stocks-lag
        "price-lag-diff"
        (dfn/- (stocks-lag "price")
               (stocks-lag "price-lag"))))
test/data/stocks.csv [5 5]:

| symbol |       date | price | price-lag | price-lag-diff |
|--------+------------+-------+-----------+----------------|
|   MSFT | 2000-01-01 | 39.81 |     39.81 |          0.000 |
|   MSFT | 2000-02-01 | 36.35 |     39.81 |         -3.460 |
|   MSFT | 2000-03-01 | 43.22 |     36.35 |          6.870 |
|   MSFT | 2000-04-01 | 28.37 |     43.22 |         -14.85 |
|   MSFT | 2000-05-01 | 25.45 |     28.37 |         -2.920 |
</code></pre>
<p>All these operations are intrinsically lazy, so values are only calculated when requested. This is usually fine but in some cases it may be desired to force the calculation of a particular column completely (like in the instance where the calculation is particularly expensive). One way to force the column efficiently is to clone it:</p>
<pre><code class="clojure">user&gt; (ds/head (ds/update-column stocks-lag "price-lag" dtype/clone))
test/data/stocks.csv [5 4]:

| symbol |       date | price | price-lag |
|--------+------------+-------+-----------|
|   MSFT | 2000-01-01 | 39.81 |     39.81 |
|   MSFT | 2000-02-01 | 36.35 |     39.81 |
|   MSFT | 2000-03-01 | 43.22 |     36.35 |
|   MSFT | 2000-04-01 | 28.37 |     43.22 |
|   MSFT | 2000-05-01 | 25.45 |     28.37 |
</code></pre>
<p>If we now get the actual type of the column’s data member, we can see that it is a concrete type.</p>
<pre><code class="clojure">user&gt; (import '[tech.ml.dataset.impl.column Column])
tech.ml.dataset.impl.column.Column
user&gt; (def concrete (ds/update-column stocks-lag "price-lag" dtype/clone))
#'user/concrete
user&gt; (type (.data ^Column (concrete "price-lag")))
[F
</code></pre>
<p>This ability - lazily define a column via interface implementation and still efficiently operate on that column - separates the implementation of the <code>tech.ml.dataset</code> library from other libraries in this field. This is likely to have an interesting and different set of advantages and disadvantages that will present themselves over time. The dataset library is very loosely bound to the underlying data representation allowing it to represent data that is much larger than can fit in memory and allowing dynamic column definitions to be defined at program runtime as equations and extensions derived from other sources of data.</p></div></div></div></body></html>